#!/usr/bin/env python3
"""
Feature Scaffold Generator for Komorebi

Generates boilerplate code for new features following project conventions.
Creates Pydantic schemas, repository, API endpoints, tests, and frontend components.

Usage:
    python generate_scaffold.py <feature_name> [--backend-only] [--frontend-only]

Example:
    python generate_scaffold.py task_management
    python generate_scaffold.py analytics --backend-only
"""

import argparse
import os
import re
from pathlib import Path
from datetime import datetime


def to_pascal_case(snake_str: str) -> str:
    """Convert snake_case to PascalCase."""
    return "".join(word.capitalize() for word in snake_str.split("_"))


def to_camel_case(snake_str: str) -> str:
    """Convert snake_case to camelCase."""
    components = snake_str.split("_")
    return components[0] + "".join(word.capitalize() for word in components[1:])


def pluralize(word: str) -> str:
    """Simple pluralization."""
    if word.endswith("y"):
        return word[:-1] + "ies"
    elif word.endswith("s"):
        return word + "es"
    else:
        return word + "s"


def generate_pydantic_schema(feature_name: str, feature_pascal: str) -> str:
    """Generate Pydantic schema file content."""
    return f'''"""
Pydantic schemas for {feature_name}.

Generated by feature-implementer skill.
"""
from datetime import datetime
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field


class {feature_pascal}Status(str, Enum):
    """Status of a {feature_name}."""
    DRAFT = "draft"
    ACTIVE = "active"
    ARCHIVED = "archived"


class {feature_pascal}Create(BaseModel):
    """Schema for creating a new {feature_name}."""
    name: str = Field(..., min_length=1, max_length=200, description="Name of the {feature_name}")
    description: Optional[str] = Field(None, max_length=2000, description="Optional description")
    # TODO: Add your custom fields here


class {feature_pascal}Update(BaseModel):
    """Schema for updating an existing {feature_name}."""
    name: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=2000)
    status: Optional[{feature_pascal}Status] = None
    # TODO: Add your custom update fields here


class {feature_pascal}(BaseModel):
    """Complete {feature_name} model returned from API."""
    id: UUID = Field(default_factory=uuid4)
    name: str
    description: Optional[str] = None
    status: {feature_pascal}Status = {feature_pascal}Status.DRAFT
    created_at: str
    updated_at: str
    # TODO: Add your custom response fields here

    class Config:
        from_attributes = True
'''


def generate_repository(feature_name: str, feature_pascal: str, feature_plural: str) -> str:
    """Generate repository file content."""
    return f'''"""
Repository for {feature_name} data access.

Generated by feature-implementer skill.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from backend.app.models.{feature_name} import {feature_pascal}, {feature_pascal}Create, {feature_pascal}Update, {feature_pascal}Status


class {feature_pascal}Repository:
    """Data access layer for {feature_plural}."""

    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, {feature_name}_create: {feature_pascal}Create) -> {feature_pascal}:
        """Create a new {feature_name}."""
        now = datetime.utcnow().isoformat()
        {feature_name} = {feature_pascal}(
            id=uuid4(),
            **{feature_name}_create.model_dump(),
            status={feature_pascal}Status.DRAFT,
            created_at=now,
            updated_at=now,
        )
        # TODO: Persist to database when ORM models are set up
        # db_{feature_name} = {feature_pascal}Table(**{feature_name}.model_dump())
        # self.session.add(db_{feature_name})
        # await self.session.commit()
        # await self.session.refresh(db_{feature_name})
        return {feature_name}

    async def get(self, {feature_name}_id: UUID) -> Optional[{feature_pascal}]:
        """Get {feature_name} by ID."""
        # TODO: Implement database query
        # result = await self.session.execute(
        #     select({feature_pascal}Table).where({feature_pascal}Table.id == str({feature_name}_id))
        # )
        # db_{feature_name} = result.scalar_one_or_none()
        # return self._to_model(db_{feature_name}) if db_{feature_name} else None
        return None

    async def list(
        self, 
        limit: int = 100, 
        offset: int = 0,
        status: Optional[{feature_pascal}Status] = None,
    ) -> list[{feature_pascal}]:
        """List {feature_plural} with optional filtering."""
        # TODO: Implement database query with filtering
        # query = select({feature_pascal}Table)
        # if status:
        #     query = query.where({feature_pascal}Table.status == status)
        # query = query.offset(offset).limit(limit)
        # result = await self.session.execute(query)
        # return [self._to_model(row) for row in result.scalars()]
        return []

    async def update(
        self, 
        {feature_name}_id: UUID, 
        {feature_name}_update: {feature_pascal}Update
    ) -> Optional[{feature_pascal}]:
        """Update an existing {feature_name}."""
        {feature_name} = await self.get({feature_name}_id)
        if not {feature_name}:
            return None
        
        # TODO: Apply updates and persist
        # update_data = {feature_name}_update.model_dump(exclude_unset=True)
        # for field, value in update_data.items():
        #     setattr(db_{feature_name}, field, value)
        # await self.session.commit()
        return {feature_name}

    async def delete(self, {feature_name}_id: UUID) -> bool:
        """Delete a {feature_name}."""
        {feature_name} = await self.get({feature_name}_id)
        if not {feature_name}:
            return False
        # TODO: Delete from database
        # await self.session.delete(db_{feature_name})
        # await self.session.commit()
        return True
'''


def generate_api_router(feature_name: str, feature_pascal: str, feature_plural: str) -> str:
    """Generate FastAPI router file content."""
    return f'''"""
API endpoints for {feature_plural}.

Generated by feature-implementer skill.
"""
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession

from backend.app.db.database import get_db
from backend.app.models.{feature_name} import {feature_pascal}, {feature_pascal}Create, {feature_pascal}Update, {feature_pascal}Status
from backend.app.repositories.{feature_name} import {feature_pascal}Repository


router = APIRouter(prefix="/{feature_plural}", tags=["{feature_plural}"])


async def get_{feature_name}_repo(db: AsyncSession = Depends(get_db)) -> {feature_pascal}Repository:
    """Dependency injection for {feature_name} repository."""
    return {feature_pascal}Repository(db)


@router.post("", response_model={feature_pascal}, status_code=201)
async def create_{feature_name}(
    {feature_name}_create: {feature_pascal}Create,
    background_tasks: BackgroundTasks,
    repo: {feature_pascal}Repository = Depends(get_{feature_name}_repo),
) -> {feature_pascal}:
    """
    Create a new {feature_name}.
    
    Returns the created {feature_name} with generated ID and timestamps.
    """
    {feature_name} = await repo.create({feature_name}_create)
    
    # TODO: Add background processing if needed
    # background_tasks.add_task(_process_{feature_name}_background, {feature_name}.id)
    
    return {feature_name}


@router.get("/{{{feature_name}_id}}", response_model={feature_pascal})
async def get_{feature_name}(
    {feature_name}_id: UUID,
    repo: {feature_pascal}Repository = Depends(get_{feature_name}_repo),
) -> {feature_pascal}:
    """
    Get a {feature_name} by ID.
    
    Raises 404 if {feature_name} not found.
    """
    {feature_name} = await repo.get({feature_name}_id)
    if not {feature_name}:
        raise HTTPException(
            status_code=404, 
            detail=f"{feature_pascal} {{{feature_name}_id}} not found"
        )
    return {feature_name}


@router.get("", response_model=list[{feature_pascal}])
async def list_{feature_plural}(
    limit: int = 100,
    offset: int = 0,
    status: Optional[{feature_pascal}Status] = None,
    repo: {feature_pascal}Repository = Depends(get_{feature_name}_repo),
) -> list[{feature_pascal}]:
    """
    List {feature_plural} with optional filtering.
    
    Args:
        limit: Maximum number of results (default 100)
        offset: Number of results to skip (default 0)
        status: Optional status filter
    """
    return await repo.list(limit=limit, offset=offset, status=status)


@router.patch("/{{{feature_name}_id}}", response_model={feature_pascal})
async def update_{feature_name}(
    {feature_name}_id: UUID,
    {feature_name}_update: {feature_pascal}Update,
    repo: {feature_pascal}Repository = Depends(get_{feature_name}_repo),
) -> {feature_pascal}:
    """
    Update an existing {feature_name}.
    
    Raises 404 if {feature_name} not found.
    """
    {feature_name} = await repo.update({feature_name}_id, {feature_name}_update)
    if not {feature_name}:
        raise HTTPException(
            status_code=404, 
            detail=f"{feature_pascal} {{{feature_name}_id}} not found"
        )
    return {feature_name}


@router.delete("/{{{feature_name}_id}}", status_code=204)
async def delete_{feature_name}(
    {feature_name}_id: UUID,
    repo: {feature_pascal}Repository = Depends(get_{feature_name}_repo),
) -> None:
    """
    Delete a {feature_name}.
    
    Raises 404 if {feature_name} not found.
    """
    deleted = await repo.delete({feature_name}_id)
    if not deleted:
        raise HTTPException(
            status_code=404, 
            detail=f"{feature_pascal} {{{feature_name}_id}} not found"
        )


async def _process_{feature_name}_background({feature_name}_id: UUID) -> None:
    """Background processing for {feature_name} (runs outside request cycle)."""
    # TODO: Implement background processing logic
    pass
'''


def generate_tests(feature_name: str, feature_pascal: str, feature_plural: str) -> str:
    """Generate pytest test file content."""
    return f'''"""
Tests for {feature_plural} API endpoints.

Generated by feature-implementer skill.
"""
import pytest
from fastapi.testclient import TestClient

from backend.app.main import app


client = TestClient(app)


# ============================================================================
# CREATE Tests
# ============================================================================

@pytest.mark.asyncio
async def test_create_{feature_name}_success():
    """Test that POST /{feature_plural} creates a {feature_name}."""
    response = client.post("/api/v1/{feature_plural}", json={{
        "name": "Test {feature_pascal}",
        "description": "Test description",
    }})
    
    assert response.status_code == 201
    data = response.json()
    
    # Verify structure
    assert "id" in data
    assert "created_at" in data
    assert "updated_at" in data
    
    # Verify values
    assert data["name"] == "Test {feature_pascal}"
    assert data["status"] == "draft"


@pytest.mark.asyncio
async def test_create_{feature_name}_validation_error():
    """Test that POST /{feature_plural} validates required fields."""
    response = client.post("/api/v1/{feature_plural}", json={{
        "name": "",  # Empty name should fail
    }})
    
    assert response.status_code == 422  # Unprocessable Entity


@pytest.mark.asyncio
async def test_create_{feature_name}_missing_field():
    """Test that POST /{feature_plural} requires name field."""
    response = client.post("/api/v1/{feature_plural}", json={{
        "description": "Missing name",
    }})
    
    assert response.status_code == 422


# ============================================================================
# READ Tests
# ============================================================================

@pytest.mark.asyncio
async def test_get_{feature_name}_success():
    """Test that GET /{feature_plural}/{{id}} returns {feature_name} details."""
    # Create a {feature_name} first
    create_response = client.post("/api/v1/{feature_plural}", json={{
        "name": "Test {feature_pascal}",
    }})
    {feature_name}_id = create_response.json()["id"]
    
    # Retrieve it
    response = client.get(f"/api/v1/{feature_plural}/{{{feature_name}_id}}")
    
    assert response.status_code == 200
    assert response.json()["id"] == {feature_name}_id


@pytest.mark.asyncio
async def test_get_{feature_name}_not_found():
    """Test that GET /{feature_plural}/{{id}} returns 404 for missing {feature_name}."""
    fake_id = "00000000-0000-0000-0000-000000000000"
    response = client.get(f"/api/v1/{feature_plural}/{{fake_id}}")
    
    assert response.status_code == 404
    assert "not found" in response.json()["detail"].lower()


# ============================================================================
# LIST Tests
# ============================================================================

@pytest.mark.asyncio
async def test_list_{feature_plural}_pagination():
    """Test that GET /{feature_plural} supports pagination."""
    # Create multiple {feature_plural}
    for i in range(10):
        client.post("/api/v1/{feature_plural}", json={{
            "name": f"Test {feature_pascal} {{i}}",
        }})
    
    # Test limit
    response = client.get("/api/v1/{feature_plural}?limit=5")
    assert response.status_code == 200
    assert len(response.json()) <= 5


@pytest.mark.asyncio
async def test_list_{feature_plural}_filter_by_status():
    """Test that GET /{feature_plural} supports status filtering."""
    response = client.get("/api/v1/{feature_plural}?status=draft")
    
    assert response.status_code == 200
    data = response.json()
    assert all({feature_name}["status"] == "draft" for {feature_name} in data)


# ============================================================================
# UPDATE Tests
# ============================================================================

@pytest.mark.asyncio
async def test_update_{feature_name}_success():
    """Test that PATCH /{feature_plural}/{{id}} updates {feature_name} fields."""
    # Create {feature_name}
    create_response = client.post("/api/v1/{feature_plural}", json={{
        "name": "Original Name",
    }})
    {feature_name}_id = create_response.json()["id"]
    
    # Update it
    response = client.patch(f"/api/v1/{feature_plural}/{{{feature_name}_id}}", json={{
        "name": "Updated Name",
        "status": "active",
    }})
    
    assert response.status_code == 200
    assert response.json()["name"] == "Updated Name"
    assert response.json()["status"] == "active"


@pytest.mark.asyncio
async def test_update_{feature_name}_not_found():
    """Test that PATCH /{feature_plural}/{{id}} returns 404 for missing {feature_name}."""
    fake_id = "00000000-0000-0000-0000-000000000000"
    response = client.patch(f"/api/v1/{feature_plural}/{{fake_id}}", json={{
        "name": "Updated",
    }})
    
    assert response.status_code == 404


# ============================================================================
# DELETE Tests
# ============================================================================

@pytest.mark.asyncio
async def test_delete_{feature_name}_success():
    """Test that DELETE /{feature_plural}/{{id}} removes {feature_name}."""
    # Create {feature_name}
    create_response = client.post("/api/v1/{feature_plural}", json={{
        "name": "To Delete",
    }})
    {feature_name}_id = create_response.json()["id"]
    
    # Delete it
    response = client.delete(f"/api/v1/{feature_plural}/{{{feature_name}_id}}")
    assert response.status_code == 204
    
    # Verify it's gone
    get_response = client.get(f"/api/v1/{feature_plural}/{{{feature_name}_id}}")
    assert get_response.status_code == 404


@pytest.mark.asyncio
async def test_delete_{feature_name}_not_found():
    """Test that DELETE /{feature_plural}/{{id}} returns 404 for missing {feature_name}."""
    fake_id = "00000000-0000-0000-0000-000000000000"
    response = client.delete(f"/api/v1/{feature_plural}/{{fake_id}}")
    
    assert response.status_code == 404
'''


def generate_signals_store(feature_name: str, feature_pascal: str, feature_plural: str) -> str:
    """Generate frontend signals store content."""
    feature_camel = to_camel_case(feature_name)
    feature_plural_camel = to_camel_case(feature_plural)
    
    return f'''/**
 * Signals store for {feature_plural}.
 * 
 * Generated by feature-implementer skill.
 */
import {{ signal, computed }} from '@preact/signals-react'

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api/v1'

// ============================================================================
// Types
// ============================================================================

export type {feature_pascal}Status = 'draft' | 'active' | 'archived'

export interface {feature_pascal} {{
    id: string
    name: string
    description?: string
    status: {feature_pascal}Status
    created_at: string
    updated_at: string
}}

export interface {feature_pascal}Create {{
    name: string
    description?: string
}}

export interface {feature_pascal}Update {{
    name?: string
    description?: string
    status?: {feature_pascal}Status
}}

// ============================================================================
// State Signals
// ============================================================================

export const {feature_plural_camel} = signal<{feature_pascal}[]>([])
export const loading = signal(false)
export const error = signal<string | null>(null)

// ============================================================================
// Computed Signals
// ============================================================================

export const {feature_camel}Stats = computed(() => {{
    const stats = {{
        draft: 0,
        active: 0,
        archived: 0,
        total: {feature_plural_camel}.value.length,
    }}
    {feature_plural_camel}.value.forEach({feature_camel} => {{
        stats[{feature_camel}.status as keyof typeof stats]++
    }})
    return stats
}})

export const {feature_plural_camel}ByStatus = computed(() => {{
    const grouped: Record<{feature_pascal}Status, {feature_pascal}[]> = {{
        draft: [],
        active: [],
        archived: [],
    }}
    {feature_plural_camel}.value.forEach({feature_camel} => {{
        grouped[{feature_camel}.status].push({feature_camel})
    }})
    return grouped
}})

// ============================================================================
// API Functions
// ============================================================================

export async function fetch{feature_pascal}s(limit = 100): Promise<void> {{
    loading.value = true
    error.value = null
    try {{
        const response = await fetch(`${{API_URL}}/{feature_plural}?limit=${{limit}}`)
        if (!response.ok) throw new Error(`HTTP ${{response.status}}`)
        const data = await response.json()
        {feature_plural_camel}.value = data
    }} catch (err) {{
        error.value = err instanceof Error ? err.message : 'Unknown error'
    }} finally {{
        loading.value = false
    }}
}}

export async function create{feature_pascal}({feature_camel}Data: {feature_pascal}Create): Promise<{feature_pascal}> {{
    loading.value = true
    error.value = null
    try {{
        const response = await fetch(`${{API_URL}}/{feature_plural}`, {{
            method: 'POST',
            headers: {{ 'Content-Type': 'application/json' }},
            body: JSON.stringify({feature_camel}Data),
        }})
        if (!response.ok) throw new Error(`HTTP ${{response.status}}`)
        const new{feature_pascal} = await response.json()
        {feature_plural_camel}.value = [...{feature_plural_camel}.value, new{feature_pascal}]
        return new{feature_pascal}
    }} catch (err) {{
        error.value = err instanceof Error ? err.message : 'Unknown error'
        throw err
    }} finally {{
        loading.value = false
    }}
}}

export async function update{feature_pascal}(
    {feature_camel}Id: string, 
    {feature_camel}Data: {feature_pascal}Update
): Promise<{feature_pascal}> {{
    loading.value = true
    error.value = null
    try {{
        const response = await fetch(`${{API_URL}}/{feature_plural}/${{{feature_camel}Id}}`, {{
            method: 'PATCH',
            headers: {{ 'Content-Type': 'application/json' }},
            body: JSON.stringify({feature_camel}Data),
        }})
        if (!response.ok) throw new Error(`HTTP ${{response.status}}`)
        const updated{feature_pascal} = await response.json()
        {feature_plural_camel}.value = {feature_plural_camel}.value.map({feature_camel} =>
            {feature_camel}.id === {feature_camel}Id ? updated{feature_pascal} : {feature_camel}
        )
        return updated{feature_pascal}
    }} catch (err) {{
        error.value = err instanceof Error ? err.message : 'Unknown error'
        throw err
    }} finally {{
        loading.value = false
    }}
}}

export async function delete{feature_pascal}({feature_camel}Id: string): Promise<void> {{
    loading.value = true
    error.value = null
    try {{
        const response = await fetch(`${{API_URL}}/{feature_plural}/${{{feature_camel}Id}}`, {{
            method: 'DELETE',
        }})
        if (!response.ok) throw new Error(`HTTP ${{response.status}}`)
        {feature_plural_camel}.value = {feature_plural_camel}.value.filter({feature_camel} => {feature_camel}.id !== {feature_camel}Id)
    }} catch (err) {{
        error.value = err instanceof Error ? err.message : 'Unknown error'
        throw err
    }} finally {{
        loading.value = false
    }}
}}
'''


def generate_react_component(feature_name: str, feature_pascal: str, feature_plural: str) -> str:
    """Generate React list component content."""
    feature_camel = to_camel_case(feature_name)
    feature_plural_camel = to_camel_case(feature_plural)
    
    return f'''/**
 * List component for {feature_plural}.
 * 
 * Generated by feature-implementer skill.
 */
import {{ useEffect, useState, useMemo }} from 'react'
import {{ {feature_plural_camel}, loading, error, fetch{feature_pascal}s }} from '../store/{feature_plural}'
import type {{ {feature_pascal}, {feature_pascal}Status }} from '../store/{feature_plural}'

type StatusFilter = 'all' | {feature_pascal}Status

export function {feature_pascal}List() {{
    // Local UI state
    const [filter, setFilter] = useState<StatusFilter>('all')
    
    // Fetch on mount
    useEffect(() => {{
        fetch{feature_pascal}s(500)
    }}, [])
    
    // Derived state (filtered list)
    const filtered{feature_pascal}s = useMemo(() => {{
        if (filter === 'all') return {feature_plural_camel}.value
        return {feature_plural_camel}.value.filter({feature_camel} => {feature_camel}.status === filter)
    }}, [{feature_plural_camel}.value, filter])
    
    return (
        <div className="{feature_name}-list-container">
            {{/* Header */}}
            <div className="{feature_name}-list-header">
                <h2>{feature_pascal}s</h2>
                <span className="count">{{filtered{feature_pascal}s.length}} items</span>
            </div>
            
            {{/* Filter controls */}}
            <div className="filter-controls" style={{{{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}}}>
                {{(['all', 'draft', 'active', 'archived'] as StatusFilter[]).map(status => (
                    <button
                        key={{status}}
                        className={{`tab ${{filter === status ? 'active' : ''}}`}}
                        onClick={{() => setFilter(status)}}
                    >
                        {{status.charAt(0).toUpperCase() + status.slice(1)}}
                    </button>
                ))}}
            </div>
            
            {{/* Error state */}}
            {{error.value && (
                <div className="error-message" style={{{{ color: 'red', marginBottom: '1rem' }}}}>
                    Error: {{error.value}}
                </div>
            )}}
            
            {{/* Content */}}
            {{loading.value && {feature_plural_camel}.value.length === 0 ? (
                <div className="loading">Loading {feature_plural}...</div>
            ) : filtered{feature_pascal}s.length === 0 ? (
                <div className="empty-state">
                    <p>No {feature_plural} found with filter: {{filter}}</p>
                </div>
            ) : (
                <div className="{feature_name}-list">
                    {{filtered{feature_pascal}s.map(({feature_camel}: {feature_pascal}) => (
                        <{feature_pascal}Card key={{{feature_camel}.id}} {feature_camel}={{{feature_camel}}} />
                    ))}}
                </div>
            )}}
        </div>
    )
}}

// Card component for individual items
interface {feature_pascal}CardProps {{
    {feature_camel}: {feature_pascal}
}}

function {feature_pascal}Card({{ {feature_camel} }}: {feature_pascal}CardProps) {{
    return (
        <div className="{feature_name}-card" style={{{{
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '1rem',
            marginBottom: '0.5rem',
        }}}}>
            <div className="card-header" style={{{{ display: 'flex', justifyContent: 'space-between' }}}}>
                <h3 style={{{{ margin: 0 }}}}>{{ {feature_camel}.name }}</h3>
                <span className={{`status-badge status-${{{feature_camel}.status}}`}} style={{{{
                    padding: '0.25rem 0.5rem',
                    borderRadius: '4px',
                    fontSize: '0.75rem',
                    backgroundColor: {feature_camel}.status === 'active' ? '#e6ffe6' : '#f0f0f0',
                }}}}>
                    {{{feature_camel}.status}}
                </span>
            </div>
            {{{feature_camel}.description && (
                <p className="description" style={{{{ color: '#666', marginTop: '0.5rem' }}}}>
                    {{{feature_camel}.description}}
                </p>
            )}}
            <div className="card-footer" style={{{{ fontSize: '0.75rem', color: '#999', marginTop: '0.5rem' }}}}>
                Created: {{new Date({feature_camel}.created_at).toLocaleDateString()}}
            </div>
        </div>
    )
}}
'''


def ensure_directory(path: Path) -> None:
    """Ensure directory exists, create if not."""
    if not path.exists():
        path.mkdir(parents=True)
        print(f"Created directory: {path}")


def write_file(path: Path, content: str) -> None:
    """Write content to file."""
    with open(path, "w") as f:
        f.write(content)
    print(f"Created file: {path}")


def generate_scaffold(
    feature_name: str, 
    backend_only: bool = False, 
    frontend_only: bool = False
) -> None:
    """Generate complete feature scaffold."""
    # Normalize feature name
    feature_name = feature_name.lower().replace("-", "_")
    feature_pascal = to_pascal_case(feature_name)
    feature_plural = pluralize(feature_name)
    
    # Determine base paths
    # Try to find project root by looking for pyproject.toml
    current = Path.cwd()
    project_root = current
    for parent in [current] + list(current.parents):
        if (parent / "pyproject.toml").exists():
            project_root = parent
            break
    
    backend_path = project_root / "backend" / "app"
    frontend_path = project_root / "frontend" / "src"
    tests_path = project_root / "backend" / "tests"
    
    print(f"\nðŸš€ Generating scaffold for feature: {feature_name}")
    print(f"   Pascal case: {feature_pascal}")
    print(f"   Plural: {feature_plural}")
    print(f"   Project root: {project_root}")
    print()
    
    # Generate backend files
    if not frontend_only:
        print("ðŸ“¦ Generating backend files...")
        
        # Models
        models_path = backend_path / "models"
        ensure_directory(models_path)
        write_file(
            models_path / f"{feature_name}.py",
            generate_pydantic_schema(feature_name, feature_pascal)
        )
        
        # Repository
        repos_path = backend_path / "repositories"
        ensure_directory(repos_path)
        write_file(
            repos_path / f"{feature_name}.py",
            generate_repository(feature_name, feature_pascal, feature_plural)
        )
        
        # API Router
        api_path = backend_path / "api"
        ensure_directory(api_path)
        write_file(
            api_path / f"{feature_plural}.py",
            generate_api_router(feature_name, feature_pascal, feature_plural)
        )
        
        # Tests
        ensure_directory(tests_path)
        write_file(
            tests_path / f"test_{feature_plural}.py",
            generate_tests(feature_name, feature_pascal, feature_plural)
        )
        
        print()
    
    # Generate frontend files
    if not backend_only:
        print("ðŸŽ¨ Generating frontend files...")
        
        # Signals store
        store_path = frontend_path / "store"
        ensure_directory(store_path)
        write_file(
            store_path / f"{feature_plural}.ts",
            generate_signals_store(feature_name, feature_pascal, feature_plural)
        )
        
        # React component
        components_path = frontend_path / "components"
        ensure_directory(components_path)
        write_file(
            components_path / f"{feature_pascal}List.tsx",
            generate_react_component(feature_name, feature_pascal, feature_plural)
        )
        
        print()
    
    print("âœ… Scaffold generation complete!")
    print()
    print("ðŸ“‹ Next steps:")
    print(f"   1. Write tests: Edit {tests_path}/test_{feature_plural}.py")
    print(f"   2. Run tests (Red): pytest backend/tests/test_{feature_plural}.py")
    print(f"   3. Implement: Fill in the TODO sections in generated files")
    print(f"   4. Run tests (Green): pytest backend/tests/test_{feature_plural}.py")
    print(f"   5. Register router in backend/app/main.py:")
    print(f"      from backend.app.api.{feature_plural} import router as {feature_plural}_router")
    print(f"      app.include_router({feature_plural}_router, prefix=\"/api/v1\")")
    print(f"   6. Update CHANGELOG.md and PROGRESS.md")


def main():
    parser = argparse.ArgumentParser(
        description="Generate feature scaffold for Komorebi"
    )
    parser.add_argument(
        "feature_name",
        help="Name of the feature (snake_case, e.g., task_management)"
    )
    parser.add_argument(
        "--backend-only",
        action="store_true",
        help="Generate only backend files"
    )
    parser.add_argument(
        "--frontend-only",
        action="store_true",
        help="Generate only frontend files"
    )
    
    args = parser.parse_args()
    
    if args.backend_only and args.frontend_only:
        parser.error("Cannot use both --backend-only and --frontend-only")
    
    generate_scaffold(
        args.feature_name,
        backend_only=args.backend_only,
        frontend_only=args.frontend_only
    )


if __name__ == "__main__":
    main()
